#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <util/delay.h>

const short a1_on[100]  = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
  1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,
  0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,
  0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0};
const short a1_off[100] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
  1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,
  0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,
  0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0};
const short a2_on[100]  = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
  1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,
  0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,
  0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0};
const short a2_off[100] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
  1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,
  0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,
  0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0};
const short a3_on[100]  = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
  1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,
  1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,
  0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0};
const short a3_off[100] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
  1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,
  1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,
  0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0};

void send(const short bits[]) {
  int t;
  for (t = 0; t < 5; t++) {
    int ix;
    for (ix = 0; ix < 100; ix++) {
      if (bits[ix] == 0) {
        PORTB = 0x00;
      } else {
        PORTB = 0x01;
      }
      _delay_us(320);
    }
  }
  _delay_ms(1);
}

void allOn() {
  //send(a1_on);
  //send(a2_on);
  //send(a3_on);
  //_delay_ms(100);
  PORTB = 0x20;
}

void allOff() {
  // send(a1_off);
  // send(a2_off);
  // send(a3_off);
  // _delay_ms(100);
  PORTB = 0x00;
}

void gotoSleep() {
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  cli();
  sleep_enable();

  MCUSR = 0;
  WDTCSR = (1<<WDCE) | (1<<WDE);
  WDTCSR = (1<<WDIE) | (1<<WDP0); // 0.032 s

  sei();
  sleep_cpu();
  sleep_disable();
}

int main(void) {
  DDRB = 0b11111111;
  PORTB = 0x00;
  DDRD = 0b11111011;
  short onOff = 0;
  short buttonState = PIND & 0x04;
  short newButtonState = newButtonState;
  while(1)
  {
    gotoSleep();
    newButtonState = PIND & 0x04;
    if (buttonState != newButtonState) {
      onOff = ~onOff;
      if (onOff == 0)
        allOff();
      else
        allOn();
      _delay_ms(1000);
    }
    buttonState = PIND & 0x04;
  }
}

ISR(WDT_vect) {
}
